/*
 *  MonteCarlo.c
 *  Yazoo
 *
 *  Created by Brian Ross on 1/4/06.
 *  Copyright 2006 __MyCompanyName__. All rights reserved.
 *
 */

#include <stdlib.h>
#include <math.h>
#include <iostream>
//#include <float.h>
//#include <stdio.h>

#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_multimin.h>
#include <gsl/gsl_multiroots.h>
#include <gsl/gsl_sort_vector.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_sf_legendre.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_eigen.h>
#include "LinMath.h"
#include "Interpolation.h"
#include "MonteCarlo.h"
#include "intrpt.h"
#include "cicada.h"

clock_t start_time_1;
time_t start_time_2;

gsl_rng *gsl_rand_gen;

//const double two_pi = 2.*pi;


// HA approx params:

InterpolationTables P_tables[6], P_tables_reordered[6], CDF_tables[6], CDF_tables_reordered[6], unbiased_P_tables[6], unbiased_P_tables_reordered[6];
ccInt segments_num, NumberOfSegmentLengths, length_index, *binIDs, dofs_num, scalar_constraints_num, dist_bin_pts, *constraint_hits;
ccInt bend_size_offset, azimuth_size_offset, *DistIDs, *UnbiasedDistIDs, *stored_segments, *constraint_segments, number_of_constraints;
int *constraint_indices;
int unbiased_bend_index, unbiased_azimuth_index;
double *P_weights, *hit_bins[6], *hit_bins_reordered[6], *dbends, *dazimuths, *PW_mults;
double *SampledModes[6], *SampledModes_reordered[6];
gsl_matrix *ModeToSSP;
gsl_vector *ModeMeans, *ModeVariances;
gsl_rng *randgen;
size_t RO_to_ordered[6];             // RO_to_ordered[reordered index] = dof # (1-5)
double *segment_step_params[6], *segment_step_params_reordered[6], *unbiased_segment_step_params_reordered[6], *logZ, *unbiased_logZ;
int unbiased_dim_list[6], dim_list[6], poly_translate_mode;      // dim_list[RO index] = # of dimensions if first dimension of that table
int *constraint_types, perturbative;
signed char *bounds_flag, *bounds_flag_RO[6], dof_number[6];
vector_3 *sampled_rs, *sampled_us, *sampled_ns, *constraint_targets;
ccBool inverted_CDFs, in_tt_coords;
double *min_bend, *max_bend, *min_azimuth, *max_azimuth, *constraint_tolerances, *constraint_mode_amplitudes;
double *amplitudes, *eigenmodes, *mode_constraint_dp, *constraint_mode_PWs;

ccBool debug_on = ccFalse;



// Next 2 routines:  evolve a chain from the initial condition given in the (r, n, b, u) of its first segment, using the specified bend/twist program

// r, u, n, and b refer to the position/orientation at the start of each link; ang_vel is the twist at the end of that link.  b is generated by this routine.
// There must be room for (segments_num+1) of each of the vectors, and the last pair of (n, b, u) will be the same as the one before it.

int call_PropagateChain(int argc, char **argv)
{
    vector_3 *r, *u, *n, *b;
    double *evolution_vectors[6];
    ccInt cD;
    arg_info *ArgInfo = (arg_info *) *(argv+argc);

    const int ArgTypes[] = { double_type, double_type, double_type, double_type, double_type,
                                     double_type, double_type, double_type, double_type, double_type, int_type };
    const int ArgIndices[] = { -1, -1, -1, -1, -2, -2, -2, -2, -2, -2, 1 };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "PropagateChain") != passed)  return 1;
    
    getArgs(argc, argv, &r, &n, &b, &u,
        &evolution_vectors[0], &evolution_vectors[1], &evolution_vectors[2], &evolution_vectors[3], &evolution_vectors[4], &evolution_vectors[5], byValue(&poly_translate_mode));
    
    r = (vector_3 *) *(argv);
    n = (vector_3 *) *(argv+1);
    b = (vector_3 *) *(argv+2);
    u = (vector_3 *) *(argv+3);
    for (cD = 0; cD <= 5; cD++)
        evolution_vectors[cD] = (double *) argv[4+cD];        // order:  shift, slide, rise, tilt, roll, twist
    
    poly_translate_mode = *(int *) *(argv+10);
    
    segments_num = ArgInfo[4].argIndices;
    
    if (ArgInfo->argIndices != 3*(segments_num+1))        {
        printf("PropagateChain() error: r[], n[], b[], u[] need to be of length segments_num+1; ang. vel. vectors[] of segments_num)\n");
        return 1;       }
    
    PropagateChain(r, n, b, u, evolution_vectors, segments_num, ccFalse, ccFalse);
    
    return passed;
}



// This procedure follows Hassan and Calladine, 1995.
// Rotate half-twist, then bend, then half-twist; translate in the half-twisted, half-bent frame.
// This uses bp coordinates.  Correspondence with wormlike chain coordinates:  x = n; y = b; z = u.

void PropagateChain(vector_3 *r, vector_3 *x, vector_3 *y, vector_3 *z, double **evolution_vectors, ccInt segments_to_prop, ccBool fixed_bend, ccBool fixed_azimuth)
{
    vector_3 hinge, msx, msy, msz;          // ms = mid-step -- see Hassan and Calladine, 1995
    ccInt link;
    double bend, twist, phi;

    for (link = 0; link < segments_to_prop; link++)    {
    
            // find the bend magnitude and direction angle phi
        
        bend = *(evolution_vectors[3]+link);
        phi = *(evolution_vectors[4]+link);
        twist = *(evolution_vectors[5]+link);
        
        
/*        if (fixed_bend)  {
            
            vector_3 to_south_pole = *y;
            vector_3 z_X_z = cross(z+0, z+link);
            double z_dot_z = dot(z+0, z+link);
            
            if (z_dot_z > 1.)  z_dot_z = 1.;
            else if (z_dot_z < -1.)  z_dot_z = -1.;
            
            *(dbends + link) = acos(z_dot_z);
            if (dot(&z_X_z, y+link) > 0)  *(dbends + link) *= -1.;
            
            bend += *(dbends + link);
            *(evolution_vectors[3]+link) = bend;        }
        
        if (fixed_azimuth)  {
            
            vector_3 z_perp = *z, y_perp = *y;
            v3GramSchmidt(&y_perp, z+link);
            v3GramSchmidt(&z_perp, z+link);
            v3GramSchmidt(&to_south_pole, z+link);
            v3GramSchmidt(&to_south_pole, &z_perp);
            Renorm(&y_perp);
            Renorm(&to_south_pole);
            
            *(dazimuths + link) = -AngleBetween(*(y+link), y_perp, *(z+link)) + twist/2.;
            
            phi += *(dazimuths + link);
            *(evolution_vectors[4]+link) = phi;        }*/
        
        
            // calculate the 'hinge' and the mid-step triad
        
        v3Rotate(y+link, z+link, twist/2. - phi, &hinge);
        v3Rotate(z+link, &hinge, bend/2., &msz);
        v3Rotate(&hinge, &msz, phi, &msy);
        msx = cross(&msy, &msz);
        
        
            // find the final orientation vector
        
        v3Rotate(z+link, &hinge, bend, z+link+1);
        v3Rotate(&hinge, z+link+1, twist/2 + phi, y+link+1);
        *(x+link+1) = cross(y+link+1, z+link+1);
        Renorm(x+link+1);
        
        
            // calculate the displacements in the 'mid-step' direction
        
        if (poly_translate_mode == -1)  Displace(r+link, evolution_vectors, link, x+link, y+link, z+link);
        else if (poly_translate_mode == 0)  Displace(r+link, evolution_vectors, link, &msx, &msy, &msz);
        else if (poly_translate_mode == 1)  Displace(r+link, evolution_vectors, link, x+link+1, y+link+1, z+link+1);
    }
}


void Displace(vector_3 *r, double **evolution_vectors, ccInt link, vector_3 *x_axis, vector_3 *y_axis, vector_3 *z_axis)
{
    vector_3 temp_v;
    
    v3ScalarMult(x_axis, *(evolution_vectors[0]+link), &temp_v);
    v3Add(r, &temp_v, r+1);
    v3ScalarMult(y_axis, *(evolution_vectors[1]+link), &temp_v);
    v3Add(r+1, &temp_v, r+1);
    v3ScalarMult(z_axis, *(evolution_vectors[2]+link), &temp_v);
    v3Add(r+1, &temp_v, r+1);
}


// Normalizes the given vector to unit length

void Renorm(vector_3 *the_v)
{
    double v_norm = sqrt(dot(the_v, the_v));
    
    if (v_norm == 0)  {  the_v->x = the_v->y = 0;  the_v->z = 1;  }
    else  v3ScalarMult(the_v, 1./v_norm, the_v);
}


// Normalizes a triad of unit vectors and orthogonalizes them

void RenormAxes(vector_3 *x, vector_3 *y, vector_3 *z)
{
    vector_3 ToSubtract;
    
    Renorm(z);
    v3ScalarMult(z, dot(z, x), &ToSubtract);
    v3Sub(x, &ToSubtract, x);
    Renorm(x);
    *y = cross(z, x);
}





// Rotates old_v about rotation_v by an angle rotation_v_norm, and returns the result in new_v
// Assumes rotation_v is normalized

void v3Rotate(vector_3 *old_v, vector_3 *rotation_v, double rotation_v_norm, vector_3 *new_v)
{
    double v_parallel;
    vector_3 v_cross, temp_v;
    
    v_parallel = dot(old_v, rotation_v);
    v_cross = cross(rotation_v, old_v);
    
    v3ScalarMult(rotation_v, v_parallel, new_v);                // the parallel component to rot_v
    
    temp_v = cross(&v_cross, rotation_v);                       // the perp component to rot_v, parallel to old_v
    v3ScalarMult(&temp_v, cos(rotation_v_norm), &temp_v);
    v3Add(new_v, &temp_v, new_v);
    
    v3ScalarMult(&v_cross, sin(rotation_v_norm), &temp_v);       // the perp component to rot_v, perp to old_v
    v3Add(new_v, &temp_v, new_v);
    Renorm(new_v);
}






#define allSix(a) &a[0],&a[1],&a[2],&a[3],&a[4],&a[5]
#define loadIT(t) &(t.StartVal),&(t.StepVal),&(t.RowSize),&(t.DataPtr)
#define allSixITs(t) loadIT(t[0]),loadIT(t[1]),loadIT(t[2]),loadIT(t[3]),loadIT(t[4]),loadIT(t[5])

// The Monte Carlo and Metropolis methods are both contained in the call_MakeChains() routine below.
// Monte Carlo evolves a chain multiple times, initializing each according to the CDFs given; saves the final r and orientation vectors in a list.
// Metropolis starts with a given chain, permutes it repeatedly and samples every N permutations.
// This routine will also, optionally, find the minimum free energy of the chain, given a list of constrains on the positions/tangents/normals of
// selected base pairs, and estimate the energy based on the size of the basin (using the saddle-point approximation of Zhang & Crothers, 2003).

int call_MakeChains(int argc, char **argv)
{
    vector_3 *r, *u, *n, *b;
    double *result, *error, *integrated_result, *ZC_result;
    ccInt LengthCounter, DistsNum, UnbiasedDistsNum;
    ccInt cD, cD2, cS, cT, cM, cN, c2, c3, to_put, last_put, subsamplings, max_runs, *runs, max_samples, *hits;
    int *DistOrder, *UnbiasedDistOrder, dim_index;
    void *make_chains_params[7];
    arg_info *ArgInfo = (arg_info *) *(argv+argc);
    ccBool fixed_bend, fixed_azimuth, rerun;
    
    const int ArgTypes[] = {
        double_type, double_type, double_type, double_type, double_type, double_type, double_type, double_type, double_type, double_type, double_type,
        double_type, double_type, double_type, double_type, double_type, int_type, int_type, double_type, double_type,
        double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type,
        double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type,
        double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type,
        double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type,
        double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type,
        double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type, double_type, double_type, int_type, double_type,
        int_type, int_type, int_type, int_type, double_type, double_type, double_type, double_type, int_type, int_type, int_type, double_type,
        double_type, int_type, double_type, bool_type, bool_type, double_type, double_type, double_type, double_type, double_type, double_type, bool_type,
        bool_type, int_type, int_type, double_type, double_type, int_type, double_type, double_type, double_type, double_type, double_type,
        double_type, int_type, bool_type  };
    
    const int ArgIndices[] = { -5, -5, -5, -5, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -7, -8,
        -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3,
        -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3,
        -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3, -1, -1, -2, -3,
        6, 6, 6, -5, -6, -6, -6, -7, 1, -8, -8, -8, -8, -9, -9, 1, 1, -10, -11, -12, -13, -14, -15, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        -16, -17, -18, -19, -20, 1 };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "MakeChains") != passed)  return 1;
    
    getArgs(argc, argv, &r, &n, &b, &u, allSix(SampledModes), allSix(segment_step_params), &UnbiasedDistIDs, &DistIDs, &unbiased_logZ, &logZ,
            allSixITs(CDF_tables), allSixITs(unbiased_P_tables), allSixITs(P_tables),
            &bounds_flag, &UnbiasedDistOrder, &DistOrder, &stored_segments, &sampled_rs, &sampled_us, &sampled_ns, &P_weights, &runs,
            &constraint_types, &constraint_segments, &constraint_tolerances, &constraint_mode_amplitudes, &constraint_indices, &constraint_targets,
            byValue(&fixed_bend), byValue(&fixed_azimuth), allSix(hit_bins), byValue(&inverted_CDFs), byValue(&perturbative), byValue(&poly_translate_mode), byValue(&subsamplings),
            &result, &error, &hits, &integrated_result, &ZC_result, &amplitudes, &eigenmodes, &mode_constraint_dp, &constraint_mode_PWs, &constraint_hits, byValue(&rerun));
    
    for (cD = 0; cD <= 5; cD++)  {
        if (loadInterpolationTable(NULL, ArgInfo+cD*4+20, &(CDF_tables[cD])) != passed)  return 1;
        if (loadInterpolationTable(NULL, ArgInfo+cD*4+44, &(unbiased_P_tables[cD])) != passed)  return 1;
        if (loadInterpolationTable(NULL, ArgInfo+cD*4+68, &(P_tables[cD])) != passed)  return 1;       }
    
    max_runs = *runs;
    
    for (cD = 0; cD < 6; cD++)  bounds_flag[cD] = 0;
    
    segments_num = ArgInfo[4].argIndices;
    if (segments_num == 0)  {
        printf("MakeChains() error: chain length must be nonzero\n");
        return 1;       }
    
    
        // check params
    
    if ((segments_num+1)*3 != ArgInfo[0].argIndices)  {
        printf("MakeChains() error:  size of r[], u[], n[], b[] not consistent w/ size of twist[], bend_direction[], bend[]\n");
        return 1;       }
    
    if (ArgInfo[99].argIndices*3 != ArgInfo[96].argIndices)  {
        printf("MakeChains() error:  size of final_r[], final_u[], n[], final_b[] not consistent w/ size of P_weights[]\n");
        return 1;       }
    
    NumberOfSegmentLengths = ArgInfo[95].argIndices;
    for (LengthCounter = 0; LengthCounter < NumberOfSegmentLengths; LengthCounter++)    {
    if (*(stored_segments+LengthCounter) > segments_num)    {
        printf("MakeChains() error:  stored_segments[%i] is greater than number of segments (%i)\n",
                            (int) LengthCounter, (int) segments_num);
        return 1;
    }}
    length_index = NumberOfSegmentLengths - 1;
    
    max_samples = ArgInfo[99].argIndices/NumberOfSegmentLengths;
    if (max_samples*NumberOfSegmentLengths != (ArgInfo+99)->argIndices)  {
        printf("MakeChains() error:  sizes of sampled_rs[], sampled_us[], sampled_ns[], ");
        printf("P_weights[] are not a multiple of number of sample lengths\n");
        return 1;       }
    
    for (cD = 0; cD <= 5; cD++)       {
    if ((CDF_tables[cD].EntriesNum == 0) || (CDF_tables[cD].DataPtr == NULL))  {
        printf("Error:  CDF_inverse table #%i not initialized properly\n", (int) cD+1);
        return 2;
    }}
    
    number_of_constraints = ArgInfo[101].argIndices;
    if ((ArgInfo+105)->argIndices != number_of_constraints*3)  {
        printf("MakeChains() error:  size of all constraint arrays must be the same\n");
        return 1;       }
    
    DistsNum = ArgInfo[20].argIndices / ArgInfo[22].argIndices;
    UnbiasedDistsNum = ArgInfo[44].argIndices / ArgInfo[46].argIndices;
    for (cS = 0; cS < segments_num; cS++)        {
    if ( (*(DistIDs + cS) >= DistsNum) || (*(UnbiasedDistIDs + cS) >= UnbiasedDistsNum) )  {
        printf("Error:  table ID must be less than the number of tables\n");
        return 3;
    }}
    
    if (rerun)  {
        make_chains_params[0] = (void *) r;
        make_chains_params[1] = (void *) u;
        make_chains_params[2] = (void *) n;      }
    else  {
        make_chains_params[0] = (void *) sampled_rs;
        make_chains_params[1] = (void *) sampled_us;
        make_chains_params[2] = (void *) sampled_ns;      }
    make_chains_params[3] = (void *) hits;
    make_chains_params[4] = (void *) b;
    make_chains_params[5] = (void *) &fixed_bend;
    make_chains_params[6] = (void *) &fixed_azimuth;
    
    min_bend = (double *) malloc(4*UnbiasedDistsNum*sizeof(double));
    max_bend = min_bend+UnbiasedDistsNum;
    min_azimuth = max_bend+UnbiasedDistsNum;
    max_azimuth = min_azimuth+UnbiasedDistsNum;
    
    for (c2 = 0; c2 < 2; c2++)  {
        const int *OneDistOrder[2] = { UnbiasedDistOrder, DistOrder };
        
        cD2 = 0;                // cD/to_put are in standard (shift/slide/.../.twist) coordinates; cD2/dim_index are in reordered coordinates
        for (cD = 0; cD <= 5; cD++)     {               // to_put/dim_index are the first indices of each table
        if (*(OneDistOrder[c2]+cD) == 0)       {
            
            ccInt tbl_index = 0, bend_dist_offset = 0, az_dist_offset = 0;
            
            dim_index = cD2;
            if (c2 == 0)  unbiased_dim_list[dim_index] = 0;
            else  dim_list[dim_index] = 0;
            
            to_put = cD;
            do  {
                if (cD2 >= 6)  {  printf("Error:  there is a problem with the DistOrder[] array\n");  return 3;  }
                
                if (c2 == 0)  {
                    if (to_put == 3)  {
                        unbiased_bend_index = cD2;
                        bend_dist_offset = tbl_index+1;     }
                    else if (to_put == 4)  {
                        unbiased_azimuth_index = cD2;
                        az_dist_offset = tbl_index+1;       }
                    unbiased_segment_step_params_reordered[cD2] = segment_step_params[to_put];
                    unbiased_P_tables_reordered[cD2] = unbiased_P_tables[to_put];            }
                else  {
                    RO_to_ordered[cD2] = to_put;
                    hit_bins_reordered[cD2] = hit_bins[to_put];
                    SampledModes_reordered[cD2] = SampledModes[to_put];
                    segment_step_params_reordered[cD2] = segment_step_params[to_put];
                    P_tables_reordered[cD2] = P_tables[to_put];
                    CDF_tables_reordered[cD2] = CDF_tables[to_put];
                    bounds_flag_RO[cD2] = bounds_flag + to_put;            }
                
                if (c2 == 0)  unbiased_dim_list[dim_index]++;
                else  dim_list[dim_index]++;
                cD2++;
                
                last_put = to_put;
                for (to_put = 0; to_put <= 5; to_put++)     {
                if (*(OneDistOrder[c2]+to_put) == last_put+1)      {
                    break;
                }}
                
                tbl_index++;
            } while (to_put < 6);
            
            if (bend_dist_offset > 0)  {
            for (cT = 0; cT < UnbiasedDistsNum; cT++)  {
                ccInt tbl_offset = unbiased_P_tables[last_put].dimensions*cT + bend_dist_offset - 1;
                *(min_bend+cT) = *(unbiased_P_tables[last_put].StartVal+tbl_offset);
                *(max_bend+cT) = *(min_bend+cT) + (*(unbiased_P_tables[last_put].StepVal+tbl_offset))
                                                    *(*(unbiased_P_tables[last_put].RowSize+bend_dist_offset-1) - 1);
            }}
            
            if (az_dist_offset > 0)  {
            for (cT = 0; cT < UnbiasedDistsNum; cT++)  {
                ccInt tbl_offset = unbiased_P_tables[last_put].dimensions*cT + az_dist_offset - 1;
                *(min_azimuth+cT) = *(unbiased_P_tables[last_put].StartVal+tbl_offset);
                *(max_azimuth+cT) = *(min_azimuth+cT) + (*(unbiased_P_tables[last_put].StepVal+tbl_offset))
                                                    *(*(unbiased_P_tables[last_put].RowSize+az_dist_offset-1) - 1);
            }}
        }}
        if (cD2 != 6)  {  printf("Error:  there is a problem with the DistOrder[] array\n");  return 3;  }
    }
    
    dofs_num = 0;
    for (cD = 0; cD < 6; cD++)  {
        if (*(CDF_tables[cD].RowSize + CDF_tables[cD].dimensions - 1) > 1)  {  dof_number[cD] = dofs_num;  dofs_num++; }
        else  dof_number[cD] = -1;     }
    dofs_num *= segments_num;
    
    dist_bin_pts = 0;
    for (cD = 0; cD <= 5; cD++)  {
        if ((dof_number[cD] >= 0) && (dist_bin_pts == 0))
            dist_bin_pts = (ArgInfo+109+cD)->argIndices / segments_num;
        if ( (((ArgInfo+109+cD)->argIndices != (ArgInfo+4*cD+71)->argIndices) && (!perturbative)) ||
                ((dof_number[cD] >= 0) && (perturbative) && (dist_bin_pts*segments_num != (ArgInfo+109+cD)->argIndices)) )      {
            printf("MakeChains() error: hit_bins[%i] has the wrong size\n", (int) cD);
            return 1;
    }   }
    
    scalar_constraints_num = 0;
    for (cN = 0; cN < number_of_constraints; cN++) {
    for (c3 = 0; c3 < 3; c3++)  {
    if (*(constraint_indices + 3*cN + c3) >= 0)   {
        scalar_constraints_num++;
    }}}
    if ((perturbative) && (scalar_constraints_num == 0))  {
        printf("MakeChains() error:  cannot use perturbative method without constraints\n");
        return 1;       }
    
    if ((perturbative) && (((ArgInfo+124)->argIndices != dofs_num) || ((ArgInfo+125)->argIndices != 6*segments_num*dofs_num) ||
            ((ArgInfo+126)->argIndices != dofs_num*scalar_constraints_num) || ((ArgInfo+127)->argIndices != max_samples*scalar_constraints_num)))  {
        printf("MakeChains() error:  wrong size for amplitudes[], eigenmodes[], mode_constraint_dp[], or constraint_mode_PWs[] array\n");
        return 1;       }
    if ((ArgInfo+128)->argIndices != number_of_constraints)  {
        printf("MakeChains() error:  wrong size for constraint_hits[] array\n");
        return 1;       }
    
    in_tt_coords = ((perturbative) && (dof_number[3] >= 0) && (dof_number[4] >= 0));
    
    RenormAxes(n, b, u);
    RenormAxes(n, b, u);           // do twice since the first RenormAxes() may set z = (0, 0, 1) if z and x are parallel
    
    bend_size_offset = CDF_tables[3].dimensions - 1;
    azimuth_size_offset = CDF_tables[4].dimensions - 1;
    
    
    binIDs = (ccInt *) malloc(6*segments_num*sizeof(ccInt));
    PW_mults = (double *) malloc(6*segments_num*sizeof(double));
    if (fixed_bend)  dbends = (double *) malloc(segments_num*sizeof(double));
    if (fixed_azimuth)  dazimuths = (double *) malloc(segments_num*sizeof(double));
    
    if ((rerun) && (perturbative))  {
        
        gsl_matrix *M = gsl_matrix_alloc((const size_t) dofs_num, (const size_t) dofs_num);
        gsl_vector *dE = gsl_vector_alloc((const size_t) dofs_num);
        gsl_vector *constraint_stiffness = gsl_vector_alloc((const size_t) scalar_constraints_num);
        gsl_vector *kc_xc_xc0 = gsl_vector_alloc((const size_t) scalar_constraints_num);
        gsl_vector *sum_kc_xc_xc0 = gsl_vector_alloc((const size_t) dofs_num);
        gsl_matrix *dc_dx = gsl_matrix_alloc((const size_t) dofs_num, (const size_t) scalar_constraints_num);
        gsl_matrix *dc_dx_old_coords = gsl_matrix_alloc((const size_t) dofs_num, (const size_t) scalar_constraints_num);
        gsl_matrix *d2c_dx2 = gsl_matrix_alloc((const size_t) dofs_num, (const size_t) dofs_num);
        gsl_matrix *dc_dx_T__dc_dx = gsl_matrix_alloc((const size_t) scalar_constraints_num, (const size_t) scalar_constraints_num);
        gsl_vector *neg_dc_dx_T__dE = gsl_vector_alloc((const size_t) scalar_constraints_num);
        gsl_matrix *tmp_n_x_n = gsl_matrix_alloc((const size_t) dofs_num, (const size_t) dofs_num);
        gsl_matrix *tmp_n_x_n_2 = gsl_matrix_alloc((const size_t) dofs_num, (const size_t) dofs_num);
        gsl_matrix *tmp_n_x_c = gsl_matrix_alloc((const size_t) dofs_num, (const size_t) scalar_constraints_num);
        gsl_matrix *tmp_c_x_c = gsl_matrix_alloc((const size_t) scalar_constraints_num, (const size_t) scalar_constraints_num);
        gsl_matrix *tmp_c_x_c_2 = gsl_matrix_alloc((const size_t) scalar_constraints_num, (const size_t) scalar_constraints_num);
        gsl_matrix *beta_beta_inv = gsl_matrix_alloc((const size_t) scalar_constraints_num, (const size_t) scalar_constraints_num);
        gsl_permutation *dc_dx_T__dc_dx_p = gsl_permutation_alloc((const size_t) scalar_constraints_num);
        gsl_permutation *n_perm = gsl_permutation_alloc((const size_t) dofs_num);
        gsl_permutation *c_perm = gsl_permutation_alloc((const size_t) scalar_constraints_num);
        gsl_eigen_symmv_workspace *eigen_workspace = gsl_eigen_symmv_alloc((const size_t) dofs_num);
        int signum;
        double E;
        ccBool bailing = ccFalse;
        
        ModeMeans = gsl_vector_alloc(dofs_num);
        ModeVariances = gsl_vector_alloc(dofs_num);
        ModeToSSP = gsl_matrix_alloc(dofs_num, dofs_num);
        
        randgen = gsl_rng_alloc(gsl_rng_ranlxs0);
        gsl_rng_set(randgen, rand());
        
        PropagateChain(r, n, b, u, segment_step_params, segments_num, ccFalse, ccFalse);      // an old conformation was provided
        
        for (cN = 0; cN < number_of_constraints; cN++) {
        for (c3 = 0; c3 < 3; c3++)  {
            int constraint_index = *(constraint_indices + 3*cN + c3);
            if (constraint_index >= 0)  {
                double mode_amp = (*(constraint_tolerances+cN)) * (*(constraint_mode_amplitudes+cN));
                gsl_vector_set(constraint_stiffness, constraint_index, 1./(mode_amp*mode_amp));
        }}  }
        
        GetStiffness(&E, dE, M);
        FixEnergies(&E, dE, M);
        FixDerivs(NULL, NULL, M, dE);
        FixDerivs(NULL, dE, NULL, NULL);
        GetConstraintDeriv(NULL, dc_dx, NULL, NULL, r, n, b, u, 0);
        gsl_matrix_memcpy(dc_dx_old_coords, dc_dx);
        FixDerivs(dc_dx, NULL, NULL, NULL);
        
//            test_grad(d2c_dx2, dc_dx, dE, constraint_stiffness, kc_xc_xc0, r, n, b, u, 1);
        
        gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1., dc_dx, dc_dx, 0., dc_dx_T__dc_dx);
        gsl_blas_dgemv(CblasTrans, -1., dc_dx, dE, 0., neg_dc_dx_T__dE);
        gsl_linalg_LU_decomp(dc_dx_T__dc_dx, dc_dx_T__dc_dx_p, &signum);
        if (gsl_linalg_LU_det(dc_dx_T__dc_dx, signum) == 0.)  {
            printf("MC.P() error:  cannot solve for constraint forces (redundant constraints?)\n");
            bailing = ccTrue;       }
        else  {
            gsl_linalg_LU_solve(dc_dx_T__dc_dx, dc_dx_T__dc_dx_p, neg_dc_dx_T__dE, kc_xc_xc0);
            
            gsl_blas_dgemv(CblasNoTrans, 1., dc_dx_old_coords, kc_xc_xc0, 0., sum_kc_xc_xc0);
            
            GetConstraintDeriv(NULL, NULL, d2c_dx2, kc_xc_xc0, r, n, b, u, 1);
            FixDerivs(NULL, NULL, d2c_dx2, sum_kc_xc_xc0);
            gsl_matrix_add(M, d2c_dx2);
            
//                test_grad(d2c_dx2, dc_dx, dE, constraint_stiffness, kc_xc_xc0, r, n, b, u, 2);
            
            gsl_matrix_memcpy(tmp_n_x_n, M);                // next block:  tmp_n_x_n = A' (Zhang & Crothers); tmp_c_x_c = F
            gsl_linalg_LU_decomp(tmp_n_x_n, n_perm, &signum);
            gsl_linalg_LU_invert(tmp_n_x_n, n_perm, tmp_n_x_n_2);
            gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1., tmp_n_x_n_2, dc_dx, 0., tmp_n_x_c);
            gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1., dc_dx, tmp_n_x_c, 0., tmp_c_x_c);
            gsl_linalg_LU_decomp(tmp_n_x_n_2, n_perm, &signum);
            gsl_linalg_LU_decomp(tmp_c_x_c, c_perm, &signum);
            *ZC_result = -E + 0.5*(dofs_num - scalar_constraints_num)*log(pi) + 0.5*(dofs_num - scalar_constraints_num)*log(2)
                        - 0.5 * (gsl_linalg_LU_lndet(tmp_n_x_n) + gsl_linalg_LU_lndet(tmp_c_x_c));
            
            gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1., dc_dx, dc_dx, 0., tmp_c_x_c);
            gsl_linalg_LU_decomp(tmp_c_x_c, c_perm, &signum);
            gsl_linalg_LU_invert(tmp_c_x_c, c_perm, beta_beta_inv);
            
            gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1., M, dc_dx, 0., tmp_n_x_c);
            gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1., dc_dx, tmp_n_x_c, 0., tmp_c_x_c);
            gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1., beta_beta_inv, tmp_c_x_c, 0., tmp_c_x_c_2);
            gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, -1., tmp_c_x_c_2, beta_beta_inv, 0., tmp_c_x_c);
for (cD = 0; cD < scalar_constraints_num; cD++)  {
for (cN = 0; cN < scalar_constraints_num; cN++)  {
//if (cD == cN)  {
gsl_matrix_set(tmp_c_x_c, cD, cN, 0.);
}}//}
            
            for (cN = 0; cN < scalar_constraints_num; cN++)
                gsl_matrix_set(tmp_c_x_c, cN, cN, gsl_vector_get(constraint_stiffness, cN) + gsl_matrix_get(tmp_c_x_c, cN, cN));
            gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1., dc_dx, tmp_c_x_c, 0., tmp_n_x_c);
            gsl_blas_dgemm(CblasNoTrans, CblasTrans, 1., tmp_n_x_c, dc_dx, 1., M);
            
            gsl_eigen_symmv(M, ModeVariances, ModeToSSP, eigen_workspace);
            
            for (cD = 0; cD < 6; cD++)  {
            if (dof_number[cD] >= 0)   {
            for (cS = 0; cS < segments_num; cS++)  {
            for (cD2 = 0; cD2 < dofs_num; cD2++)  {
                *(eigenmodes + 6*segments_num*cD2 + 6*cS + cD) = gsl_matrix_get(ModeToSSP, dof_number[cD]*segments_num+cS, cD2);
            }}}}
            
            gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1., ModeToSSP, dc_dx, 0., tmp_n_x_c);
            for (cD = 0; cD < dofs_num; cD++)  {
            for (cN = 0; cN < scalar_constraints_num; cN++)  {
                *(mode_constraint_dp + cD*scalar_constraints_num + cN) = gsl_matrix_get(tmp_n_x_c, (const size_t) cD, (const size_t) cN);
            }}
            
            *integrated_result = -E + 0.5*(dofs_num-scalar_constraints_num)*log(2*pi);
            for (cD = 0; cD < dofs_num; cD++)
                *integrated_result -= 0.5*log(gsl_vector_get(ModeVariances, (const size_t) cD));
            gsl_linalg_LU_decomp(tmp_c_x_c, c_perm, &signum);
            *integrated_result += 0.5 * gsl_linalg_LU_lndet(tmp_c_x_c);
            
            for (cD = 0; cD < dofs_num; cD++)  {
            
                double tot_dp = 0., one_var = gsl_vector_get(ModeVariances, cD);
                
                for (cD2 = 0; cD2 < 6; cD2++)  {
                if (dof_number[cD2] >= 0)   {
                for (cS = 0; cS < segments_num; cS++)  {
                    tot_dp += gsl_matrix_get(ModeToSSP, dof_number[cD2]*segments_num+cS, cD) * (*(segment_step_params[cD2]+cS));
                }}}
                gsl_vector_set(ModeMeans, cD, tot_dp);
                
                if (one_var > 0.)  {
                    gsl_vector_set(ModeVariances, cD, 1./sqrt(one_var));
                    *(amplitudes + cD) = gsl_vector_get(ModeVariances, (const size_t) cD);         }
                
                else  {
                    
                    for (cD2 = 0; cD2 < 6; cD2++)  {
                    for (cS = 0; cS < segments_num; cS++)  {
                        if (dof_number[cD2] < 0)   *(segment_step_params[cD2] + cS) = 0.;
                        else  *(segment_step_params[cD2] + cS) = gsl_matrix_get(ModeToSSP, dof_number[cD2]*segments_num+cS, cD);
                    }}
                    
                    printf("\nMC.P() error:  mode %i is unstable (eigenvalue %g; the eigenvector will be stored in MC.trajectory)\n", (int) cD, one_var);
                    bailing = ccTrue;          }
                    
                if (bailing)  break;
        }   }
        
        gsl_matrix_free(M);
        gsl_vector_free(dE);
        gsl_vector_free(constraint_stiffness);
        gsl_vector_free(kc_xc_xc0);
        gsl_vector_free(sum_kc_xc_xc0);
        gsl_matrix_free(dc_dx);
        gsl_matrix_free(dc_dx_old_coords);
        gsl_matrix_free(d2c_dx2);
        gsl_matrix_free(dc_dx_T__dc_dx);
        gsl_matrix_free(tmp_n_x_n);
        gsl_matrix_free(tmp_n_x_n_2);
        gsl_matrix_free(tmp_n_x_c);
        gsl_matrix_free(tmp_c_x_c);
        gsl_matrix_free(tmp_c_x_c_2);
        gsl_matrix_free(beta_beta_inv);
        gsl_vector_free(neg_dc_dx_T__dE);
        gsl_permutation_free(dc_dx_T__dc_dx_p);
        gsl_permutation_free(n_perm);
        gsl_permutation_free(c_perm);
        gsl_eigen_symmv_free(eigen_workspace);
        if (bailing)  {
            gsl_vector_free(ModeMeans);
            gsl_vector_free(ModeVariances);
            gsl_rng_free(randgen);
            return 3;           }
    }
    
    
        // evolve the chains & save their final positions and orientations
    
    if (rerun)
        GetMeanAndError(runs, max_samples, subsamplings, ccFalse, ccFalse, &MakeChain, make_chains_params, result, error);
    else
        GetMeanAndError(&max_samples, max_samples, subsamplings, ccFalse, ccTrue, &MeasureConcentration, make_chains_params, result, error);
    
    
    if ((rerun) && (perturbative))  gsl_matrix_free(ModeToSSP);
    
    free(binIDs);
    free(PW_mults);
    if (fixed_bend)  free((void *) dbends);
    if (fixed_azimuth)  free((void *) dazimuths);
    free(min_bend);
    
    
        // normalize the hit_bins tables
    
    if ((!perturbative) && (rerun) && (max_runs > 0))  {
    for (cT = 0; cT < DistsNum; cT++)  {
        cD = 0;
        do      {
            double sum = 0, old_sum = 0;
            int table_index = cD+dim_list[cD]-1;
            
            for (cD2 = 0; cD2 < P_tables_reordered[table_index].EntriesNum; cD2++)  {
                ccInt idx = cT*P_tables_reordered[table_index].EntriesNum + cD2;
                old_sum += (*(P_tables_reordered[table_index].DataPtr + idx));
                sum += *(hit_bins_reordered[table_index] + idx);                }
            
            if (sum != 0.)  {
            for (cD2 = 0; cD2 < P_tables_reordered[table_index].EntriesNum; cD2++)  {
                *(hit_bins_reordered[table_index] + cT*P_tables_reordered[table_index].EntriesNum + cD2) *= old_sum/sum;      }}
            
            cD += dim_list[cD];
        }  while (cD < 6);
    }}
    
    else if ((perturbative) && (rerun) && (max_runs > 0))  {
    for (cD = 0; cD < 6; cD++)  {
    if (dof_number[cD] >= 0)  {
    for (cS = 0; cS < segments_num; cS++)  {
        
        double sum = 0.;
        
        for (cM = 0; cM < dist_bin_pts; cM++)  {
            sum += *(hit_bins[cD] + cS*dist_bin_pts + cM);                }
        sum *= 10. / (dist_bin_pts-1);
        
        if (sum != 0.)  {
        for (cM = 0; cM < dist_bin_pts; cM++)  {
            *(hit_bins[cD] + cS*dist_bin_pts + cM) /= sum;                }}
    }}}}
    
    if ((rerun) && (perturbative))  {
        
        gsl_vector_free(ModeMeans);
        gsl_vector_free(ModeVariances);
        gsl_rng_free(randgen);          }
    
    return passed;
}



double MakeChain(ccInt offset, void **Params)
{
    ccInt cS, cM, cN, cD, cD2, LengthCounter;
    double workspace[6], conc;
    vector_3 *r, *u, *n, *b;
    int no_derivs[6] = { 0, 0, 0, 0, 0, 0 };
    ccBool fixed_bend, fixed_azimuth;
    
    r = (vector_3 *) *(Params + 0);
    n = (vector_3 *) *(Params + 2);
    b = (vector_3 *) *(Params + 4);
    u = (vector_3 *) *(Params + 1);
    fixed_bend = *(ccBool *) *(Params + 5);
    fixed_azimuth = *(ccBool *) *(Params + 6);
    
    if (!perturbative)  {
        cD = 0;
        do      {
            SampleDistribution(&(CDF_tables_reordered[cD]), DistIDs, &(SampledModes_reordered[cD]),
                               dim_list[cD], segments_num, no_derivs, workspace, inverted_CDFs);
            cD += dim_list[cD];
        }  while (cD < 6);          }
    
    else  {
        for (cD = 0; cD < 6; cD++) {
        if (dof_number[cD] >= 0)  {
        for (cS = 0; cS < segments_num; cS++)  {
            size_t idx = dof_number[cD]*segments_num + cS;
            *(SampledModes[cD] + cS) = gsl_vector_get(ModeMeans, idx) + gsl_ran_gaussian(randgen, gsl_vector_get(ModeVariances, idx));
    }   }}}
    
    if (!perturbative)  {
        
        for (cD = 0; cD < 6; cD++)  {
        for (cS = 0; cS < segments_num; cS++)  {
            *(segment_step_params[cD] + cS) = *(SampledModes[cD] + cS);
    }   }}
    
    else  {
        for (cD = 0; cD < 6; cD++)  {
        if (dof_number[cD] >= 0)  {
        for (cS = 0; cS < segments_num; cS++)  {
            ccInt idx0 = segments_num*dof_number[cD] + cS;
            *(segment_step_params[cD] + cS) = 0;
            for (cD2 = 0; cD2 < 6; cD2++)  {
            if (dof_number[cD2] >= 0)  {
            for (cM = 0; cM < segments_num; cM++)  {
                *(segment_step_params[cD] + cS) += (*(SampledModes[cD2] + cM)) * gsl_matrix_get(ModeToSSP, idx0, segments_num*dof_number[cD2] + cM);
        }}} }}}
        
        if (in_tt_coords)  {
        for (cS = 0; cS < segments_num; cS++)  {
            double t1 = *(segment_step_params[3]+cS), t2 = *(segment_step_params[4]+cS);
            double t = sqrt(t1*t1 + t2*t2), p;
            
            if (t1 == 0.)  p = pi/2;
            else  p = atan(t2/t1);
            if (t1 < 0.)  p += pi;
            
            *(segment_step_params[3]+cS) = t;
            *(segment_step_params[4]+cS) = p;
        }}
        
        for (cD = 0; cD < 6; cD++)  {
        if ((perturbative) && (dof_number[cD] < 0))  {
        for (cS = 0; cS < segments_num; cS++)  {
            *(segment_step_params[cD] + cS) = *(P_tables[cD].StartVal);
    }   }}}
    
    PropagateChain(r, n, b, u, segment_step_params, segments_num, fixed_bend, fixed_azimuth);
    for (LengthCounter = 0; LengthCounter < NumberOfSegmentLengths; LengthCounter++)   {
        *(sampled_rs + offset + LengthCounter) = *(r + *(stored_segments+LengthCounter));
        *(sampled_us + offset + LengthCounter) = *(u + *(stored_segments+LengthCounter));
        *(sampled_ns + offset + LengthCounter) = *(n + *(stored_segments+LengthCounter));        }
    
    conc = MeasureConcentration(offset, Params);
    if (conc == 1.)  {
        
        ccInt first_segment = 0;
        double total_P_weight = 0.;
        
        for (LengthCounter = 0; LengthCounter < NumberOfSegmentLengths; LengthCounter++)   {
            
            for (cS = first_segment; cS < (*(stored_segments+LengthCounter)); cS++)     {
                
                ccInt oneID = *(DistIDs+cS), oneUnbiasedID = *(UnbiasedDistIDs+cS);
                ccBool changed_azimuth;
                
                if (fixed_bend)  *(segment_step_params[3] + cS) -= *(dbends + cS);
                if (fixed_azimuth)  *(segment_step_params[4] + cS) -= *(dazimuths + cS);
                
                
                    // calculate the hit bin IDs
                
                if (!perturbative)    {
                    cD = 0;
                    do      {
                        ccInt idx = cD*segments_num + cS, bin_offset = 0;
                        int table_list_start = oneID*dim_list[cD];
                        InterpolationTables *one_E_table = &(P_tables_reordered[cD+dim_list[cD]-1]);
                        
                        *(PW_mults + idx) = 1.;
                        for (cD2 = 0; cD2 < dim_list[cD]; cD2++)  {
                            double one_step = *(SampledModes_reordered[cD+cD2]+cS);
                            
                            int one_bin = ceil((one_step - (*(one_E_table->StartVal+table_list_start+cD2))) 
                                               / (*(one_E_table->StepVal+table_list_start+cD2)) - 0.5);
                            bin_offset = bin_offset * (*(one_E_table->RowSize+cD2)) + one_bin;
                            if ((one_bin == 0) || (one_bin == *(one_E_table->RowSize+cD2)-1))  *(PW_mults + idx) *= 2;           }
                        
                        *(binIDs + idx) = oneID*one_E_table->EntriesNum + bin_offset;
                        cD += dim_list[cD];
                    }  while (cD < 6);              }
                
                else  {
                    for (cD = 0; cD < 6; cD++)  {
                    if (dof_number[cD] >= 0)  {
                        size_t idx = dof_number[cD]*segments_num + cS;
                        double sigma = gsl_vector_get(ModeVariances, idx);
                        
                        int one_bin = ceil(dist_bin_pts * (*(SampledModes_reordered[cD]+cS) - (gsl_vector_get(ModeMeans, idx) - 5*sigma)) / (10*sigma) - 0.5);
                        if (one_bin < 0)  {  one_bin = 0;  bounds_flag[cD] = -1;  }
                        else if (one_bin >= dist_bin_pts)  {  one_bin = dist_bin_pts-1;  bounds_flag[cD] = 1;  }
                        
                        *(binIDs + idx) = cS*dist_bin_pts + one_bin;
                }   }}
                
                
                    // get the biased energy
                
                if (!perturbative)  {
                    
                    for (cD = 0; cD < 6; cD++)  *(workspace+cD) = *(segment_step_params_reordered[cD]+cS);
                    
                    cD = 0;
                    do      {
                        total_P_weight -= log(Interpolate(&(P_tables_reordered[cD+dim_list[cD]-1]), oneID, workspace+cD, no_derivs, NULL));
                        cD += dim_list[cD];
                    }  while (cD < 6);             }
                
                else {
                    
                    for (cD = 0; cD < 6; cD++)  {
                    if (dof_number[cD] >= 0)  {
                        double sigma = gsl_vector_get(ModeVariances, dof_number[cD]*segments_num + cS);
                        double mode_amp = (*(SampledModes[cD] + cS)) - gsl_vector_get(ModeMeans, dof_number[cD]*segments_num + cS);
                        total_P_weight += 0.5*log(2*pi) + log(sigma) + mode_amp*mode_amp/(2*sigma*sigma);
                    }}
                    if (in_tt_coords)  total_P_weight -= log(fabs(*(segment_step_params[3]+cS)));
                }
                
                
                
                
                    // try to ensure that bend/azimuth are in the range of the unbiased tables
                
                if (fixed_bend)  *(segment_step_params[3] + cS) += *(dbends + cS);
                if (fixed_azimuth)  *(segment_step_params[4] + cS) += *(dazimuths + cS);
                
                changed_azimuth = ccFalse;
                for (cD = 0; cD < 6; cD++)  *(workspace+cD) = *(unbiased_segment_step_params_reordered[cD]+cS);
                if ((*(workspace + unbiased_bend_index) < *(min_bend+oneUnbiasedID)) || (*(workspace + unbiased_bend_index) > *(max_bend+oneUnbiasedID)))  {
                if ((-(*(workspace + unbiased_bend_index)) >= *(min_bend+oneUnbiasedID)) &&
                                (-(*(workspace + unbiased_bend_index)) <= *(max_bend+oneUnbiasedID)))  {
                    *(workspace + unbiased_bend_index) *= -1.;
                    if (bounds_flag[4] == 0)  changed_azimuth = ccTrue;
                    *(workspace + unbiased_azimuth_index) += pi;    }}
                if (fixed_bend)  *(workspace + unbiased_bend_index) -=
                                2*pi*floor(((*(workspace + unbiased_bend_index)) - *(min_bend+oneUnbiasedID))/(2*pi));
                *(workspace + unbiased_azimuth_index) -= 2*pi*floor(((*(workspace + unbiased_azimuth_index)) - *(min_azimuth+oneUnbiasedID))/(2*pi));
                
                
                    // subtract the unbiased energy
                
                cD = 0;
                do      {
                    total_P_weight += log(Interpolate(&(unbiased_P_tables_reordered[cD+unbiased_dim_list[cD]-1]),
                                                                oneUnbiasedID, workspace+cD, no_derivs, &(bounds_flag_RO[cD])));
                    cD += unbiased_dim_list[cD];
                }  while (cD < 6);
                if ((bounds_flag[4] != 0) && (changed_azimuth))  {
                    if (-(*(workspace + unbiased_bend_index)) < *(min_bend+oneUnbiasedID))  bounds_flag[3] = -1;
                    else  bounds_flag[3] = 1;
                    bounds_flag[4] = 0;         }
            
                total_P_weight += (*(logZ + oneID)) - (*(unbiased_logZ + oneUnbiasedID));
            }
            
            first_segment = cS;
            *(P_weights + offset + LengthCounter) = total_P_weight;
        }
        
        
            // add to the hit bins
        
        total_P_weight = exp(total_P_weight);
        
        if (!perturbative)    {
            cD = 0;
            do      {
                for (cS = 0; cS < segments_num; cS++)  {
                    ccInt idx = cD*segments_num + cS;
                    *(hit_bins_reordered[cD+dim_list[cD]-1] + *(binIDs + idx)) += (*(PW_mults + idx))*total_P_weight;     }
                cD += dim_list[cD];
            }  while (cD < 6);              }
        
        else  {
            for (cD = 0; cD < 6; cD++)  {
            if (dof_number[cD] >= 0)  {
            for (cS = 0; cS < segments_num; cS++)  {
                ccInt c3, idx = dof_number[cD]*segments_num + cS;
                *(hit_bins[cD] + *(binIDs + idx)) += total_P_weight;
                
                for (cN = 0; cN < number_of_constraints; cN++) {
                for (c3 = 0; c3 < 3; c3++)  {
                    int constraint_idx = *(constraint_indices + 3*cN + c3);
                    if (constraint_idx >= 0)  {
                        *(constraint_mode_PWs + (offset/NumberOfSegmentLengths)*scalar_constraints_num + constraint_idx) += 
                                ((*(SampledModes[cD] + cS)) - gsl_vector_get(ModeMeans, idx))
                                * (*(mode_constraint_dp + idx*scalar_constraints_num + constraint_idx)) / (*(constraint_tolerances+cN));
        }   }}} }}  }
    }
    
    return conc;
}


// GetE() calculates the gradient/2nd derivative vector in the free energy function.

void GetStiffness(double *E, gsl_vector *dE, gsl_matrix *K)
{
    ccInt cS, cD, cD2, cD3;
    double one_step[6];
    int deriv_vector[6] = { 0, 0, 0, 0, 0, 0 };
    signed char **bounds_flag_pass, *bounds_flag_storage[6];
    
    bounds_flag_pass = &(bounds_flag_storage[0]);
    
    *E = 0;
    gsl_matrix_set_zero(K);
    
    for (cS = 0; cS < segments_num; cS++)  {
        
        cD = 0;
        do  {
            for (cD2 = 0; cD2 < dim_list[cD]; cD2++)  {
                one_step[cD2] = *(segment_step_params_reordered[cD+cD2]+cS);
                bounds_flag_storage[cD2] = bounds_flag_RO[cD+cD2];      }
            
            for (cD2 = 0; cD2 < dim_list[cD]; cD2++)  {
            for (cD3 = 0; cD3 <= cD2; cD3++)  {
                
                double new_el;
                double ps[4];
                char cp, idx1 = dof_number[RO_to_ordered[cD + cD2]], idx2 = dof_number[RO_to_ordered[cD + cD3]];
                
                if ((idx1 >= 0) && (idx2 >= 0))     {
                    
                    for (cp = 0; cp < 4; cp++)  {
                        deriv_vector[cD2] = cp % 2;
                        if (cp > 1)  deriv_vector[cD3]++;
                        
                        ps[cp] = Interpolate(&(P_tables_reordered[cD+dim_list[cD]-1]),      // P_tables are really unbiased_E_tables
                                             *(UnbiasedDistIDs + cS), one_step, deriv_vector, bounds_flag_pass);   }
                    
                    *E += ps[0];
                    
                    gsl_vector_set(dE, idx1*segments_num+cS, ps[1]);
                    
                    new_el = ps[3];
                    gsl_matrix_set(K, idx1*segments_num+cS, idx2*segments_num+cS, new_el);
                    gsl_matrix_set(K, idx2*segments_num+cS, idx1*segments_num+cS, new_el);
                    
                    deriv_vector[cD2] = deriv_vector[cD3] = 0;
            }}  }
            
            cD += dim_list[cD];
        }  while (cD < 6);
    }
}


// GetConstraintDeriv() computes the gradient in the cost ('c') functions.  Computes the total gradient if constraints_num is its full value;
// to get a gradient in one direction pass the relevant indices of constraint_indices[] and constraint_vectors[] and set constraints_num = 1.
// Order of terms in gradient:  0..5:  shift->twist of { r0 -> u0 }; 6..N+5:  shifts of subsequent segments; N+6..2N+5:  slides...
// Four modes of operation:  0 - get dc_dx;  1 - get addition to d2c_dx2 (sum d2c_mult*dc_dx) after calling modes (2, 3) to get dc_dx, same-bp elements of d2c_dx2;
//    [ 2 - get dc_dx in u/n/b (not x/y/z) coordinates;  3 - get same-cS-elements of d2c_dx2 using (2) ].

void GetConstraintDeriv(gsl_vector *c, gsl_matrix *dc_dx, gsl_matrix *d2c_dx2, gsl_vector *d2c_mult, vector_3 *r, vector_3 *n, vector_3 *b, vector_3 *u, char mode)
{
    char constraint_dof;
    ccInt cD, cD2, cS, cN, ca, cve3, constraint_index;
    int cpm, cpm_bottom;
    vector_3 *coords[4] = { r, n, b, u }, v_error, dv, rotated_vector, r2[2], n2[2], b2[2], u2[2], r2b[2], n2b[2], b2b[2], u2b[2], *es[3] = { NULL, NULL, NULL };
    vector_3 *orig_axes[3], *new_axes[3] = { &(n2[1]), &(b2[1]), &(u2[1]) }, *new_axes_b[3] = { &(n2b[1]), &(b2b[1]), &(u2b[1]) };
    double perturbed_step_params[6], *perturbed_step_addresses[6], orig_psp, orig_psp2, epsilon;
    const double epsilons[2] = { 1.e-8, 1.e-4 };
    
    if (mode != 3)  cpm_bottom = 1;
    else  cpm_bottom = -1;
    
    if (c != NULL)      {
    for (cN = 0; cN < number_of_constraints; cN++)  {
        double v_error_3[3];
        
        constraint_dof = *(constraint_types+cN);
        constraint_index = *(constraint_segments+cN);           // may not work when rerun == false (in MC.zoo)?  constraint_segments is then index of STORED segments
        
        v3Sub(coords[constraint_dof] + constraint_index, constraint_targets + cN, &v_error);
        if (*(constraint_indices + cN*3 + 0) < 0)  v_error.x = 0;
        if (*(constraint_indices + cN*3 + 1) < 0)  v_error.y = 0;
        if (*(constraint_indices + cN*3 + 2) < 0)  v_error.z = 0;
        v3Put(&v_error, v_error_3);
        
        for (cve3 = 0; cve3 < 3; cve3++)        {
            int one_scalar_index = *(constraint_indices + cN*3 + cve3);
            if (one_scalar_index >= 0)   {
                gsl_vector_set(c, (size_t) one_scalar_index, v_error_3[cve3]);
    }}  }   }
    
    if (mode == 0)  gsl_matrix_set_zero(dc_dx);
    if (mode == 1)  gsl_matrix_set_zero(d2c_dx2);
    
    if (mode == 1)  {
        ccInt cSC;
        int *tmp_constraint_indices = constraint_indices;
        
        constraint_indices = (int *) malloc(3*number_of_constraints*sizeof(int));
        
        for (cSC = 0; cSC < 3*number_of_constraints; cSC++)  *(constraint_indices+cSC) = cSC;
        
        dc_dx = gsl_matrix_calloc((size_t) d2c_dx2->size1, (size_t) 3*number_of_constraints);          // d2c_dx2->size1 = dofs_num
        GetConstraintDeriv(NULL, dc_dx, d2c_dx2, d2c_mult, r, n, b, u, 2);
        
        free(constraint_indices);
        constraint_indices = tmp_constraint_indices;
        
        GetConstraintDeriv(NULL, NULL, d2c_dx2, d2c_mult, r, n, b, u, 3);
    }
    
    if ((mode == 0) || (mode == 2))  epsilon = epsilons[0];
    else  epsilon = epsilons[1];
    
    for (cD = 0; cD < 6; cD++)  perturbed_step_addresses[cD] = &(perturbed_step_params[cD]);
    
    for (cS = 0; cS < segments_num; cS++)  {
        
        if (mode == 2)  {
            es[0] = n+cS+1;
            es[1] = b+cS+1;
            es[2] = u+cS+1;            }
        
        r2[0] = r2b[0] = *(r+cS);
        n2[0] = n2b[0] = *(n+cS);  b2[0] = b2b[0] = *(b+cS);  u2[0] = u2b[0] = *(u+cS);
        for (cD = 0; cD < 6; cD++)  perturbed_step_params[cD] = *(segment_step_params[cD] + cS);
        
        orig_axes[0] = n+cS+1;
        orig_axes[1] = b+cS+1;
        orig_axes[2] = u+cS+1;
        
        for (cD = 0; cD < 6; cD++)  {
        if (dof_number[cD] >= 0)  {
        for (cD2 = 0; cD2 <= cD; cD2++)  {
        if (dof_number[cD2] >= 0)  {
            
            ccInt cD_index = segments_num*dof_number[cD] + cS;
            ccInt cD2_index = segments_num*dof_number[cD2] + cS;
            
            orig_psp = perturbed_step_params[cD];
            orig_psp2 = perturbed_step_params[cD2];
            
            for (cpm = 1; cpm >= cpm_bottom; cpm -= 2)  {
                
                if (mode == 3)  perturbed_step_params[cD2] += cpm*epsilon;
                perturbed_step_params[cD] += epsilon;
                PropagateChain(&(r2[0]), &(n2[0]), &(b2[0]), &(u2[0]), perturbed_step_addresses, 1, ccFalse, ccFalse);
                perturbed_step_params[cD] -= 2*epsilon;
                PropagateChain(&(r2b[0]), &(n2b[0]), &(b2b[0]), &(u2b[0]), perturbed_step_addresses, 1, ccFalse, ccFalse);
                perturbed_step_params[cD] = orig_psp;
                perturbed_step_params[cD2] = orig_psp2;
                
                for (cN = 0; cN < number_of_constraints; cN++)  {
                    
                    constraint_dof = *(constraint_types+cN);
                    constraint_index = *(constraint_segments+cN);
                    
                    if (cS < constraint_index)     {
                        
                        if ((constraint_dof == 0) && (mode != 1))  {             // R constraint:  account for changes in extension
                            
                            v3Sub(&(r2[1]), &(r2b[1]), &dv);
                            StoreCostDeriv(dc_dx, d2c_dx2, d2c_mult, 0.5*cpm, &dv, cD_index, cD2_index, cN, epsilon, es, mode);    }
                        
                        if (cD > 2)  {           // angular dof:  account for changes in R/angle constraints due to rotation
                            
                            if (constraint_dof == 0)  v3Sub(coords[0]+constraint_index, coords[0]+cS+1, &rotated_vector);
                            else  rotated_vector = *(coords[constraint_dof]+constraint_index);
                            
                            for (ca = 0; ca <= 2; ca++)     {
                                v3Sub(new_axes[ca], new_axes_b[ca], &dv);
                                if (mode != 1)  StoreCostDeriv(dc_dx, d2c_dx2, d2c_mult, dot(&rotated_vector, orig_axes[ca]) * 0.5*cpm,
                                                               &dv, cD_index, cD2_index, cN, epsilon, es, mode);
                                else    {
                                    ccInt cS2, cDb, c3, ca2;
                                    double dv3[3];
                                    
                                    v3Put(&dv, dv3);
                                    
                                    if (constraint_index >= cS)    {         // cS is offset by 1
                                    for (cS2 = cS+1; cS2 < constraint_index; cS2++)   {
                                    for (cDb = 0; cDb < 6; cDb++)  {
                                    if (dof_number[cDb] >= 0)  {
                                        
                                        ccInt cDb_index = segments_num*dof_number[cDb] + cS2;
                                        
                                        es[0] = n+cS2+1;
                                        es[1] = b+cS2+1;
                                        es[2] = u+cS2+1;
                                        
                                        for (ca2 = 0; ca2 < 3; ca2++)      {
                                        for (c3 = 0; c3 < 3; c3++)      {
                                            ccInt one_scalar_index = *(constraint_indices + 3*cN + c3);
                                            if (one_scalar_index >= 0)   {
                                                gsl_matrix_set(d2c_dx2, cD_index, cDb_index, gsl_matrix_get(d2c_dx2, cD_index, cDb_index)
                                                               + (0.5/epsilon) * gsl_vector_get(d2c_mult, (size_t) one_scalar_index)
                                                               * gsl_matrix_get(dc_dx, cDb_index, 3*cN+ca2) * dot(orig_axes[ca], es[ca2]) * dv3[c3]);
                                                gsl_matrix_set(d2c_dx2, cDb_index, cD_index, gsl_matrix_get(d2c_dx2, cD_index, cDb_index));
                                        }}   }
                                }   }}}}
            }   }   }   }   }
            
            if (mode != 3)  break;         // from cD2 loop
    }   }}}}
    
    if (mode == 1)  gsl_matrix_free(dc_dx);
}


// StoreCostDeriv() stores a gradient in a constraint function.

void StoreCostDeriv(gsl_matrix *dc_dx, gsl_matrix *d2c_dx2, gsl_vector *d2c_mult, double scale, vector_3 *dv, size_t idx1, size_t idx2,
                    ccInt constraint_num, double step_size, vector_3 **es, char mode)
{
    ccInt c3;
    double dv3[3], to_add;
    gsl_matrix *the_mat;
    
    v3Put(dv, dv3);
    if (mode != 3)  the_mat = dc_dx;
    else  the_mat = d2c_dx2;
    
    for (c3 = 0; c3 < 3; c3++)  {
        int scalar_constraint_offset = *(constraint_indices + 3*constraint_num + c3);
        if (scalar_constraint_offset >= 0)   {
            if (mode != 2)  to_add = scale * dv3[c3] / step_size;
            else  to_add = scale * dot(dv, *(es+c3)) / step_size;
            if (mode == 3)  to_add *= gsl_vector_get(d2c_mult, (size_t) scalar_constraint_offset) / (2*step_size);
            else  idx2 = (size_t) scalar_constraint_offset;
            
            gsl_matrix_set(the_mat, idx1, idx2, gsl_matrix_get(the_mat, idx1, idx2) + to_add);
            if (mode == 3)  gsl_matrix_set(the_mat, idx2, idx1, gsl_matrix_get(the_mat, idx1, idx2));
    }   }
}



void FixEnergies(double *E, gsl_vector *dE, gsl_matrix *d2E_dx2)
{
    ccInt cS;
    
    if (!in_tt_coords)  return;
    
    for (cS = 0; cS < segments_num; cS++)  {
        double t = *(segment_step_params[3] + cS);                  // t = theta
        size_t theta_index = segments_num*dof_number[3] + cS;
        
        *E += log(fabs(t));
        gsl_vector_set(dE, theta_index, gsl_vector_get(dE, theta_index) + 1./t);
        gsl_matrix_set(d2E_dx2, theta_index, theta_index, gsl_matrix_get(d2E_dx2, theta_index, theta_index) - 1./(t*t));
    }
}



void FixDerivs(gsl_matrix *dc_dx, gsl_vector *dE, gsl_matrix *d2M_dx2, gsl_vector *dM_dx)
{
    ccInt cS, cS2, cD, cC;
    
    if (!in_tt_coords)  return;
    
    if (((dc_dx != NULL) || (dE != NULL)) && (dof_number[4] >= 0))  {
    for (cS = 0; cS < segments_num; cS++)  {
        double t = *(segment_step_params[3] + cS);                  // t = theta
        size_t phi_index = segments_num*dof_number[4] + cS;
        
        if (t != 0.)    {           // otherwise d/dphi should equal zero
            if (dE != NULL)  gsl_vector_set(dE, phi_index, gsl_vector_get(dE, phi_index) / sin(t));
            
            if (dc_dx != NULL)  {
            for (cC = 0; cC < scalar_constraints_num; cC++)     {
                gsl_matrix_set(dc_dx, phi_index, (size_t) cC, gsl_matrix_get(dc_dx, phi_index, (size_t) cC) / sin(t));
    }}  }   }}
    
    
    if ((d2M_dx2 != NULL) && (dof_number[4] >= 0))  {
    for (cS = 0; cS < segments_num; cS++)  {
        double t = *(segment_step_params[3] + cS);                  // t = theta
        double E_t = 0, E_p, E_tp = 0, E_pp;    // dE/dtheta, dE/dphi, d^2E/dphi^2, etc.
        size_t theta_index = segments_num*dof_number[3] + cS, phi_index = segments_num*dof_number[4] + cS;
        size_t x2_index, p1_index = segments_num*dof_number[4] + cS;
        double t1 = *(segment_step_params[3] + cS);
        
            // 1. -- correct theta/phi terms in d2M_dx2 belonging to the same segment
            
        E_p = gsl_vector_get(dM_dx, phi_index);
        E_pp = gsl_matrix_get(d2M_dx2, phi_index, phi_index);
        
        if (dof_number[3] >= 0)    {
            
            E_t = gsl_vector_get(dM_dx, theta_index);
            E_tp = gsl_matrix_get(d2M_dx2, theta_index, phi_index);
            
            if (t != 0.)     {
                gsl_matrix_set(d2M_dx2, theta_index, phi_index, E_tp/sin(t) - E_p/(sin(t)*tan(t)));
                gsl_matrix_set(d2M_dx2, phi_index, theta_index, E_tp/sin(t) - E_p/(sin(t)*tan(t)));
        }   }
        
        if ((t == 0.) && (E_t == 0) && (E_pp == 0))   {          // degenerate case -- E_t ~ t*E_tt
            if (dof_number[3] >= 0)
                gsl_matrix_set(d2M_dx2, phi_index, phi_index, gsl_matrix_get(d2M_dx2, theta_index, theta_index));
            else
                gsl_matrix_set(d2M_dx2, phi_index, phi_index, 0.);      }
        else
            gsl_matrix_set(d2M_dx2, phi_index, phi_index, E_pp/(sin(t)*sin(t)) + E_t/tan(t));
        
        
            // 2. -- Adjust d^2f/dtheta_dx terms in d2M_dx2 where 'x' is either on a different segment, or is a non-theta/non-phi coordinate
        
        for (cS2 = 0; cS2 < segments_num; cS2++)  {
        for (cD = 0; cD < 6; cD++)     {
        if (dof_number[cD] >= 0)    {
        if ((cS != cS2) || ((cD != 3) && (cD != 4)))    {
            
            x2_index = segments_num*dof_number[cD] + cS2;
            
            gsl_matrix_set(d2M_dx2, p1_index, x2_index, gsl_matrix_get(d2M_dx2, p1_index, x2_index) / sin(t1));
            gsl_matrix_set(d2M_dx2, x2_index, p1_index, gsl_matrix_get(d2M_dx2, x2_index, p1_index) / sin(t1));
    }}  }}}}
}


void test_grad(gsl_matrix *M, gsl_matrix *dc_dx, gsl_vector *dE, gsl_vector *constraint_stiffness, gsl_vector *kc_xc_xc0,
                vector_3 *r, vector_3 *n, vector_3 *b, vector_3 *u, char tst_mode)
{             // used for testing the cost function gradient, and the 1st/2nd derivatives of the 'f' functions (see Zhang & Crothers)
    ccInt cD, cN, cS, cDBG, cDBGb, cDBG_c, cDBGb_top, cZero;
    gsl_vector *c0 = gsl_vector_alloc((size_t) scalar_constraints_num);
    gsl_vector *c1 = gsl_vector_alloc((size_t) scalar_constraints_num);
    gsl_vector *ca = gsl_vector_alloc((size_t) scalar_constraints_num);
    gsl_vector *cb = gsl_vector_alloc((size_t) scalar_constraints_num);
    gsl_matrix *tst_M = gsl_matrix_calloc((size_t) dofs_num, (size_t) dofs_num);
    gsl_matrix *tst_dc_dx = gsl_matrix_alloc((size_t) dofs_num, (size_t) scalar_constraints_num);
    double epsilon, *tst_grad = (double *) malloc((size_t) dofs_num * sizeof(double));
    double *hold_grad_E = (double *) malloc((size_t) dofs_num * sizeof(double));
    double val_cutoff = 1.e-5;
    
    printf("\n\nTEST\n\n");
    if (tst_mode == 2)  {
        printf("xc - x0c balance:\n");
        for (cD = 0; cD < dofs_num; cD++)  {
            double tot = gsl_vector_get(dE, cD);
            for (cN = 0; cN < scalar_constraints_num; cN++)  {
                tot += gsl_vector_get(kc_xc_xc0, cN) * gsl_matrix_get(dc_dx, cD, cN);   }
            if (tot*tot > val_cutoff*val_cutoff)  printf(" *************** Problem here:  ");
            printf("%g\n", tot);    }
        printf("\n\n");         }
    
    if (tst_mode == 1)  {
        cDBGb_top = 1;
        epsilon = 1.e-8;            }
    else        {
        epsilon = 1.e-4;
        if (in_tt_coords)  {
        for (cS = 0; cS < segments_num; cS++)  {
            size_t t_index = dof_number[3]*segments_num + cS, p_index = dof_number[4]*segments_num + cS;
            double E_tp = gsl_matrix_get(tst_M, t_index, p_index);
            double E_pp = gsl_matrix_get(tst_M, p_index, p_index);
            double E_t = gsl_vector_get(dE, t_index), E_p = gsl_vector_get(dE, p_index);
            double t = *(segment_step_params[3] + cS);
            
            gsl_matrix_set(tst_M, t_index, p_index, E_tp/sin(t) - E_p/(sin(t)*tan(t)));
            gsl_matrix_set(tst_M, p_index, t_index, E_tp/sin(t) - E_p/(sin(t)*tan(t)));
            gsl_matrix_set(tst_M, p_index, p_index, E_pp/(sin(t)*sin(t)) + E_t/tan(t));
        }}
        gsl_matrix_scale(tst_M, 0.5);
        cDBGb_top = dofs_num;     }
    
    for (cDBG = 0; cDBG < dofs_num; cDBG++)        {
    for (cDBGb = 0; cDBGb < cDBGb_top; cDBGb++)        {
    for (cDBG_c = 0; cDBG_c < scalar_constraints_num; cDBG_c++)        {
        
        double val1 = 0., val2 = 0.;
        
        if (cDBG_c == 0)  val2 = 0;   //gsl_matrix_get(tst_M, cDBG, cDBGb);
        
        for (cZero = 0; cZero < dofs_num; cZero++)  *(tst_grad + cZero) = 0;
        
        sample_grads(c1, tst_dc_dx, r, n, b, u, tst_grad, cDBGb, epsilon, ccTrue);         // here c1 is just a dummy -- use this to add epsilon to cDBGb
        sample_grads(c1, tst_dc_dx, r, n, b, u, tst_grad, cDBG, epsilon, ccTrue);
        sample_grads(cb, tst_dc_dx, r, n, b, u, tst_grad, cDBGb, -2*epsilon, ccFalse);
        sample_grads(ca, tst_dc_dx, r, n, b, u, tst_grad, cDBG, -2*epsilon, ccFalse);
        sample_grads(c0, tst_dc_dx, r, n, b, u, tst_grad, cDBGb, 2*epsilon, ccFalse);
        
        if (tst_mode == 1)      {
            val1 = gsl_matrix_get(dc_dx, (size_t) cDBG, (size_t) cDBG_c);
            val2 = (gsl_vector_get(c1, (size_t) cDBG_c) - gsl_vector_get(c0, (size_t) cDBG_c))/(2*epsilon);
            if ( (cDBGb == 0) && ((fabs(val1) > val_cutoff) || (fabs(val2) > val_cutoff)) )       {
                if (fabs((val1-val2)/(val1+val2)) > 1.e-3)  printf(" *************** Problem here:  ");
                printf("(b) %i %i:  %g %g\n", (int) cDBG, (int) cDBG_c, val1, val2);     }            }
        
        else        {
            val1 = gsl_matrix_get(M, (size_t) cDBG, (size_t) cDBGb);
            val2 += gsl_vector_get(kc_xc_xc0, cDBG_c) * (        // kc_xc_xc0 was already multiplied by constraint_stiffness
                        (gsl_vector_get(c1, (size_t) cDBG_c) - gsl_vector_get(c0, (size_t) cDBG_c))
                                - (gsl_vector_get(cb, (size_t) cDBG_c) - gsl_vector_get(ca, (size_t) cDBG_c)) ) / (4*epsilon*epsilon);
            if ( ((fabs(val1) > val_cutoff) || (fabs(val2) > val_cutoff)) && (cDBG_c == scalar_constraints_num-1))     {
                if (fabs((val1-val2)/(val1+val2)) > 1.e-2)  printf(" *************** Problem here:  ");
                printf("(D) %i %i:  %g %g\n", (int) cDBG, (int) cDBGb, val1, val2);     }       }
    }}}
    
    PropagateChain(r, n, b, u, segment_step_params, segments_num, ccFalse, ccFalse);
    free(tst_grad);  free(hold_grad_E);
    printf("\n\nEND TEST\n\n");
}


// sample_grads():  used for testing.
// Manually computes the derivatives of the Lagrange 'f' functions (see Zhang and Crothers) with respect to the coordinates;
// these derivatives can be compared to the derivatives calculated by GetConstraintDeriv().

void sample_grads(gsl_vector *c, gsl_matrix *dc_dx, vector_3 *r, vector_3 *n, vector_3 *b, vector_3 *u,
                  double *tst_grad, ccInt idx, double idx_change, ccBool clear_fixed_phi)
{
    ccInt cD, cS;
    double *t_index = NULL, *a_index = NULL, t0 = 0., a0 = 0., t = 0, a = 0;
    static double fixed_phi;    // in calculating derivatives the first phi needs to flip between 0/pi when we vary theta
    int mode = 0;
    
    if (clear_fixed_phi)  fixed_phi = 0;
    
    if (in_tt_coords)  {
        
        ccInt bp_step = 0;
        
        if ((idx >= segments_num*dof_number[3]) && (idx < segments_num*(dof_number[3]+1)))  {
            mode = 1;
            bp_step = idx - segments_num*dof_number[3];
            t_index = tst_grad + idx;
            a_index = tst_grad + segments_num*dof_number[4] + bp_step;      }
        
        else if ((idx >= segments_num*dof_number[4]) && (idx < segments_num*(dof_number[4]+1)))  {
            mode = 2;
            bp_step = idx - segments_num*dof_number[4];
            t_index = tst_grad + segments_num*dof_number[3] + bp_step;
            a_index = tst_grad + idx;      }
        
        t0 = *(segment_step_params[3] + bp_step);
        a0 = *(segment_step_params[4] + bp_step);
        
        if (mode != 0)  {
            t = t0 + *t_index;
            a = a0 + *a_index;          }       }
    
    if (mode == 0)  *(tst_grad + idx) += idx_change;
    
    else  {
        double x, y, z, x_zc, z_zc, t_zc, t1, t2, new_t, a_guess;
        
        x = sin(t)*cos(a-a0);
        y = sin(t)*sin(a-a0);
        z = cos(t);
        
        x_zc = x*cos(t0) - z*sin(t0);
        z_zc = z*cos(t0) + x*sin(t0);
        
        t_zc = sg_angle(&z_zc, sqrt(x_zc*x_zc+y*y));
        if (t_zc == 0.)
            t1 = t2 = 0.;
        else    {
            t1 = (t_zc/sin(t_zc))*x_zc;
            t2 = (t_zc/sin(t_zc))*y;     }
        
        if (mode == 1)  t1 += idx_change;
        else  t2 += idx_change;
        
        t_zc = sqrt(t1*t1 + t2*t2);
        if (t_zc == 0.)  {
            x_zc = y = 0.;
            z_zc = 1.;       }
        else    {
            x_zc = t1*(sin(t_zc)/t_zc);
            y = t2*(sin(t_zc)/t_zc);
            z_zc = cos(t_zc);     }
        
        x = x_zc*cos(t0) + z_zc*sin(t0);
        z = z_zc*cos(t0) - x_zc*sin(t0);
        
        new_t = sg_angle(&z, sqrt(x*x+y*y));
        *t_index = new_t - t0;
        
        if (new_t == 0.)  a_guess = 0.;
        else  {
            double x_norm = x/sin(new_t);
            a_guess = sg_angle(&x_norm, y/sin(new_t));
            if (y < 0.)  a_guess *= -1.;        }
        
        *a_index = a_guess + 2*pi*floor((*a_index-a_guess)/(2*pi) + 0.5);           }
    
    for (cD = 0; cD < 6; cD++)  {
    if (dof_number[cD] >= 0)  {
    for (cS = 0; cS < segments_num; cS++)  {
        *(segment_step_params[cD] + cS) = (*(segment_step_params[cD] + cS)) + (*(tst_grad + segments_num*dof_number[cD] + cS));
    }}}
    PropagateChain(r, n, b, u, segment_step_params, segments_num, ccFalse, ccFalse);
    GetConstraintDeriv(c, dc_dx, NULL, NULL, r, n, b, u, 0);
    for (cD = 0; cD < 6; cD++)  {
    if (dof_number[cD] >= 0)  {
    for (cS = 0; cS < segments_num; cS++)  {
        *(segment_step_params[cD] + cS) = (*(segment_step_params[cD] + cS)) - (*(tst_grad + segments_num*dof_number[cD] + cS));
    }}}
}

double sg_angle(double *z, double xy)
{
    double angle;
    
    if (*z < -1.)  *z = -1.;
    else if (*z > 1.)  *z = 1.;
    
    if ((*z)*(*z) < .9)  angle = acos(*z);
    else    {
        angle = asin(fabs(xy));
        if (*z < 0.)  angle = pi - angle;        }
    
    return angle;
}



double MeasureConcentration(ccInt offset, void **Params)
{
    ccInt cN;
    vector_3 *rs, *us, *ns, delta_r;
    double rtrn = 1;
    
    rs = (vector_3 *) *Params;
    us = (vector_3 *) *(Params+1);
    ns = (vector_3 *) *(Params+2);
    
    for (cN = 0; cN < number_of_constraints; cN++) {
        
        vector_3 *one_v = constraint_targets+cN;
        ccInt offset2 = *(constraint_segments+cN);
        double max_dc = *(constraint_tolerances+cN);
        
        if (rs == sampled_rs)  offset2 += offset;
        
        if (*(constraint_types+cN) == 0)  {
            v3Sub(rs+offset2, one_v, &delta_r);
            if (*(constraint_indices+cN*3+0) < 0)  delta_r.x = 0.;
            if (*(constraint_indices+cN*3+1) < 0)  delta_r.y = 0.;
            if (*(constraint_indices+cN*3+2) < 0)  delta_r.z = 0.;
            
            if (dot(&delta_r, &delta_r) >= max_dc*max_dc)  rtrn = 0.;
            else  (*(constraint_hits + cN))++;         }
        
        else  {
            double v_dp;
            
            if (*(constraint_types+cN) == 1)  v_dp = dot(ns+offset2, one_v);
            else if (*(constraint_types+cN) == 2)  {  vector_3 one_b = cross(us+offset2, ns+offset2);  v_dp = dot(&one_b, one_v);  }
            else if (*(constraint_types+cN) == 3)  v_dp = dot(us+offset2, one_v);
            
            if (v_dp < cos(max_dc))  rtrn = 0.;
            else  (*(constraint_hits + cN))++;         }
    }
    
    if (rtrn > 0.)  (*(ccInt *) *(Params+3))++;
    
    return rtrn;
}



// Next 2 routines:  measure <R^2>, <R^4>, etc.

int call_Measure_R_2N(int argc, char **argv)
{
    ccInt numSamples, Moment, subsamplings;
    double *result, *error;
    arg_info *ArgInfo = (arg_info *) *(argv+argc);
    void *params[1];
    
    const int ArgTypes[] = { double_type, double_type, int_type, int_type, int_type, int_type, double_type, double_type };
    const int ArgIndices[] = { -1, -2, 1, 1, 1, 1, 1, 1 };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "Measure_R_2N") != passed)  return 1;
    
    getArgs(argc, argv, &sampled_rs, &P_weights, byValue(&NumberOfSegmentLengths), byValue(&length_index), byValue(&Moment), byValue(&subsamplings), &result, &error);
    
    numSamples = ArgInfo[1].argIndices / NumberOfSegmentLengths;
    
    if (numSamples*NumberOfSegmentLengths*3 != ArgInfo[0].argIndices)   {
        printf("r[] and P_weights[] needs to be of type vector_3 and of the same length\n");
        return 3;       }
    
    params[0] = (void *) &Moment;
    
    GetMeanAndError(&numSamples, numSamples, subsamplings, ccTrue, ccTrue, &Measure_R_2N, params, result, error);
    
    return passed;
}

double Measure_R_2N(ccInt offset, void **Params)
{
    ccInt HalfMomentCounter, offset2 = offset + length_index;
    double HalfMoment, One_R_2N, One_R_sq;
    const ccInt MaxMultipliedMoments = 10;
    
    HalfMoment = *(ccInt *) *Params;

    if (HalfMoment <= MaxMultipliedMoments) {
        One_R_sq = dot(sampled_rs + offset2, sampled_rs + offset2);
        One_R_2N = 1;
        for (HalfMomentCounter = 1; HalfMomentCounter <= HalfMoment; HalfMomentCounter++)  One_R_2N *= One_R_sq;
    }

    else  One_R_2N = pow(dot(sampled_rs + offset2, sampled_rs + offset2), HalfMoment);
    
    return One_R_2N;
}



// Next 2 routines:  measure the mean of:  the component of R along the initial tangent vector raised to the given power

int call_Measure_R_dot_u0(int argc, char **argv)
{
    vector_3 *u0;
    ccInt numSamples, Moment, subsamplings;
    double *result, *error;
    arg_info *ArgInfo = (arg_info *) *(argv+argc);
    void *params[2];

    const int ArgTypes[] = { double_type, double_type, double_type, int_type, int_type, int_type, int_type, double_type, double_type };
    const int ArgIndices[] = { -1, -2, 3, 1, 1, 1, 1, 1, 1 };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "Measure_R_dot_u0") != passed)  return 1;
    
    getArgs(argc, argv, &sampled_rs, &P_weights, &u0, byValue(&NumberOfSegmentLengths), byValue(&length_index), byValue(&Moment), byValue(&subsamplings), &result, &error);
    
    numSamples = ArgInfo[1].argIndices / NumberOfSegmentLengths;
    
    if (numSamples*NumberOfSegmentLengths*3 != ArgInfo[0].argIndices) {
        printf("r[] and P_weights[] needs to be of type vector_3 and of the same length\n");
        return 3;       }
    
    params[0] = (void *) u0;
    params[1] = (void *) &Moment;
    
    GetMeanAndError(&numSamples, numSamples, subsamplings, ccTrue, ccTrue, &Measure_R_dot_u0, params, result, error);
    
    return passed;
}

double Measure_R_dot_u0(ccInt offset, void **Params)
{
    double One_R_dot_u0_N, One_R_dot_u0;
    vector_3 *u0;
    ccInt Moment, MomentCounter, offset2 = offset + length_index;
    const ccInt MaxMultipliedMoments = 6;
    
    u0 = (vector_3 *) *Params;
    Moment = *(ccInt *) *(Params+1);
    
    if (Moment <= MaxMultipliedMoments) {
        One_R_dot_u0 = dot(sampled_rs + offset2, u0);
        One_R_dot_u0_N = 1;
        for (MomentCounter = 1; MomentCounter <= Moment; MomentCounter++)  One_R_dot_u0_N *= One_R_dot_u0;
    }
    
    else  One_R_dot_u0_N = pow(dot(sampled_rs + offset2, u0), Moment);
    
    return One_R_dot_u0_N;
}



void GetMeanAndError(ccInt *max_runs, ccInt max_samples, ccInt Subsamplings, ccBool divide_PW_sum, ccBool use_all_samples,
            double(*SampleFunction)(ccInt, void **), void **params, double *mean, double *error)
{
    ccInt counter, sample_counter, last_group = 0, group;
    double sub_mean = 0, group_mean = 0, group_mean_sq = 0, one_sample, P_weight_sum, group_P_weights = 0;
    
    *mean = P_weight_sum = 0;
    if (*max_runs == 0)  {  *error = 0;  return;  }
    
    sample_counter = 0;
    for (counter = 0; counter <= *max_runs; counter++)      {          // the last iteration is one too many, but we break from it
        
        ccInt offset = sample_counter*NumberOfSegmentLengths, offset2 = offset + length_index;
        
        group = (ccInt) floor(counter*Subsamplings/(*max_runs));
        if ((ccInt) floor(sample_counter*Subsamplings/max_samples) > group)
            group = (ccInt) floor(sample_counter*Subsamplings/max_samples);
        
        if (group > last_group)     {
            
            *mean += sub_mean;                  // do this first, since we count *mean by summing all measurements, not all sub_means
            P_weight_sum += group_P_weights;
            
            if (divide_PW_sum)  sub_mean /= group_P_weights;
            else  sub_mean /= (*max_runs)/Subsamplings;
            
            group_mean += sub_mean;
            group_mean_sq += sub_mean*sub_mean;
            
            sub_mean = 0;
            group_P_weights = 0;
            
            if ((counter == *max_runs) || (sample_counter == max_samples))  break;
        }
        
        one_sample = SampleFunction(offset, params);
        
        sub_mean += exp(*(P_weights+offset2)) * one_sample;
        group_P_weights += exp(*(P_weights+offset2));
        
        if ((one_sample != 0.) || (use_all_samples))  sample_counter++;
        last_group = group;                     }
    
    group_mean /= Subsamplings;
    group_mean_sq /= Subsamplings;
    
    if (divide_PW_sum)  *mean /= P_weight_sum;
    else  *mean /= *max_runs;
    
    *error = sqrt((group_mean_sq - group_mean*group_mean) / (Subsamplings-1));
    
    *max_runs = counter;        // max_runs is now sampled runs
}







// Next 2 routines:  evolve a chain from the initial condition given in the (r, n, b, u) of its first segment, using the specified bend/twist program

// r, u, n, and b refer to the position/orientation at the start of each link; ang_vel is the twist at the end of that link.  b is generated by this routine.
// There must be room for (segments_num+1) of each of the vectors, and the last pair of (n, b, u) will be the same as the one before it.

int call_CountChainCrossings(int argc, char **argv)
{
    double *r;
    int x, y, z;
    int *crossings, cSA, cSB;
    arg_info *ArgInfo = (arg_info *) *(argv+argc);
    
    const int ArgTypes[] = { double_type, int_type, int_type };
    const int ArgIndices[] = { -1, 1, 1 };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "CountChainCrossings") != passed)  return 1;
    
    getArgs(argc, argv, &r, byValue(&z), &crossings);
    
    r = (double *) *(argv);
    z = *(int *) *(argv+1);
    crossings = (int *) *(argv+2);
    
    if (z == 0)  {  x = 1; y = 2;  }
    else if (z == 1)  {  x = 2; y = 0;  }
    else if (z == 2)  {  x = 0; y = 1;  }
    else  {  printf("CountChainCrossings() error:  view_axis must be 0 (x), 1 (y) or 2 (z)\n");  return 2;  }
    
    segments_num = (ArgInfo+0)->argIndices / 3 - 1;
    
    if (ArgInfo->argIndices != 3*(segments_num+1))        {
        printf("CountChainCrossings() error: r[], n[], b[], u[] need to be of length segments_num+1)\n");
        return 1;       }
    
    *crossings = 0;
    
    for (cSA = 1; cSA < segments_num; cSA++)    {
        
        double A1x = *(r + 3*cSA + x), A2x = *(r + 3*(cSA+1) + x);
        double A1y = *(r + 3*cSA + y), A2y = *(r + 3*(cSA+1) + y);
        double dAx = A2x - A1x, dAy = A2y - A1y;
        
        for (cSB = 0; cSB < cSA-2; cSB++)     {
            
            double B1x = *(r + 3*cSB + x), B2x = *(r + 3*(cSB+1) + x);
            double B1y = *(r + 3*cSB + y), B2y = *(r + 3*(cSB+1) + y);
            double dBx = B2x - B1x, dBy = B2y - B1y;
            
            double A1B1x = B1x - A1x;
            double A1B1y = B1y - A1y;
            
            double uv_norm = dAx * dBy - dBx * dAy;
            double u = (A1B1x * dBy - A1B1y * dBx) / uv_norm;
            double v = (A1B1x * dAy - A1B1y * dAx) / uv_norm;
            
            if ((u >= 0.) && (u <= 1.) && (v >= 0.) && (v <= 1.) )      {
                double Az = (1. - u) * (*(r + 3*cSA + z)) + u * (*(r + 3*(cSA+1) + z));
                double Bz = (1. - v) * (*(r + 3*cSB + z)) + v * (*(r + 3*(cSB+1) + z));
                
                if ((cSA < segments_num-1) || (cSB > 0))  {
                    if ( (Az-Bz) * (dAx*dBy - dAy*dBx) > 0 )  (*crossings)++;
                    else  (*crossings)--;
            }   }
    }   }
    
    return passed;
}



/**************** For benchmarking program speed *******************/

// Return 2 independent estimates of time spent between the two function calls, based on 1) clock cycles and 2) time in seconds.
// I included the lower-precision ordinary time because I'm always having problems with the clock-cycles count (inaccurate, wrapping around, etc.).


int call_StartTimer(int argc, char **argv)
{
    arg_info *ArgInfo = (arg_info *) *(argv+argc);

    const int ArgTypes[] = {  };
    const int ArgIndices[] = {  };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "StartTimer") != passed)  return 1;
    
    start_time_1 = clock();
    start_time_2 = time(NULL);
    
    return passed;
}


int call_StopTimer(int argc, char **argv)
{
    double *t1, *t2;
    clock_t stop_time_1;
    time_t stop_time_2;
    arg_info *ArgInfo = (arg_info *) *(argv+argc);
    
    const int ArgTypes[] = { double_type, double_type };
    const int ArgIndices[] = { 1, 1 };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "StopTimer") != passed)  return 1;
    
    getArgs(argc, argv, &t1, &t2);
    
    stop_time_1 = clock();
    stop_time_2 = time(NULL);
    
    *t1 = (double) ( ((double) (stop_time_1 - start_time_1)) / CLOCKS_PER_SEC );
    *t2 = difftime(stop_time_2, start_time_2);
    
    return passed;
}




/**************** For controlling the random numbers generated *******************/


int call_SetRND(int argc, char **argv)
{
    return SetGetRND(argc, argv, 1);
}


int call_GetRND(int argc, char **argv)
{
    return SetGetRND(argc, argv, 2);
}


int SetGetRND(int argc, char **argv, ccInt mode)
{
    arg_info *ArgInfo = (arg_info *) *(argv+argc);
    ccInt *num;
    
    const int ArgTypes[] = { int_type };
    const int ArgIndices[] = { 1 };
    
    if (CheckArgInfo(ArgInfo, ArgTypes, ArgIndices, argc, sizeof(ArgTypes)/sizeof(int), "Set/GetRND") != passed)  return 1;
    
    getArgs(argc, argv, &num);
    
    if (mode == 1)  {
        srand((unsigned int) *num);
        gsl_rng_set(gsl_rand_gen, (ccInt) *num);       }
    else  *num = (ccInt) rand();
    
    return passed;
}
